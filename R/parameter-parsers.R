#' @include utilities.R
#' @include McmcParameters.R
NULL

#' Parse MCMC parameter names
#'
#' Functions that parse a vector of flat parameter names
#' and return an object of
#'
#' These functions are provided as an argument to \code{\link{mcmc_parse_parnames}}.
#' 
#' \describe{
#' \item{\code{mcmc_parparser_bugs}}{Parses parameter names
#' in the Stan style, e.g. \code{"beta[1,1]"}}
#' \item{\code{mcmc_parparser_stan}}{Parses parameter names
#' treating each parameter as a scalar. E.g. \code{"beta.1"}
#' and \code{"beta.2"} will be treated two parameter arrays of
#' size 1.}
#' \item{\code{mcmc_parparser_stan}}{Parses parameter names
#' in the Stan style, e.g. \code{"beta.1.1"}}
#' \item{\code{mcmc_parparser_guess}}{Tries to guess the format of the parameters}
#' }
#'
#' @param x \code{character} vector with flat parameter names.
#' @return Object of class \code{McmcFlatparList}
#'
#' @rdname mcmc_parparsers
#' @aliases mcmc_parparsers_scalar
#' @seealso \code{\link{mcmc_parse_parnames}} which takes these functions an argument.
#' @export
#' @examples
#' mcmc_parparser_bugs(c("beta[1]", "beta[2]"))
#' mcmc_parparser_stan(c("beta.1", "beta.2"))
#' mcmc_parparser_scalar(c("beta[1]", "beta[2]"))
mcmc_parparser_scalar <- function(x) {
  ret <- mapply(function(pararray, index)
                McmcFlatpar(pararray=pararray, index=index),
         x, 1, SIMPLIFY=FALSE)
  names(ret) <- x
  McmcFlatparList(ret)
}

#' @rdname mcmc_parparsers
#' @aliases mcmc_parparsers_stan
#' @export
mcmc_parparser_stan <- function(x) {
  x2 <- str_split_fixed(x, fixed("."), 2)
  indices <- llply(str_split(x2[ , 2], fixed(".")),
                   function(x) ifelse(x == "", 1, as.integer(x)))
  ret <- mapply(function(pararray, index)
                McmcFlatpar(pararray=pararray, index=index),
                x2[ , 1], indices, SIMPLIFY=FALSE)
  names(ret) <- x
  McmcFlatparList(ret)
}

#' @rdname mcmc_parparsers
#' @aliases mcmc_parparsers_bugs
#' @export
mcmc_parparser_bugs <- function(x) {
  x2 <- str_match(x, "([^\\[]+)(\\[([0-9,]+)\\])?")[ , c(2, 4)]
  indices <- llply(str_split(x2[ , 2], fixed(",")),
                   function(x) ifelse(x == "", 1, as.integer(x)))
  ret <- mapply(function(pararray, index)
                McmcFlatpar(pararray=pararray, index=index),
                x2[ , 1], indices, SIMPLIFY=FALSE)
  names(ret) <- x
  McmcFlatparList(ret)
}

#' @rdname mcmc_parparsers
#' @aliases mcmc_parparsers_guess
#' @export
mcmc_parparser_guess <- function(x) {
  if (all(valid_mcmc_parnames(x, "stan"))) {
    mcmc_parparser_stan(x)
  } else if (all(valid_mcmc_parnames(x, "bugs"))) {
    mcmc_parparser_bugs(x)
  } else {
    mcmc_parparser_scalar(x)
  }
}


#' Create McmcPararrayList from McmcFlatparList
#'
#' @param x \linkS4class{McmcFlatparList}
#' @return Object of class \linkS4class{McmcPararrayList}
#' @keywords internal
create_pararrays <- function(x) {
  xpars <- sapply(x, slot, "pararray")
  pararrays <- unique(xpars)
  pardims <-
    lapply(pararrays,
           function(i) {
             apply(do.call(rbind, lapply(x[xpars == i], slot, "index")),
                   2, max)
           })
  flatpars <- lapply(pararrays, function(i) names(xpars)[xpars == i])
  ret <- McmcPararrayList(mapply(function(x, y) {
    McmcPararray(dim = x, flatpars = y)
  }, pardims,  flatpars))
  names(ret) <- pararrays
  ret
}

#' Create McmcParameter object from MCMC parameter names
#'
#' @param x \code{character} vector of parameter names
#' @param parser \code{function} parse \code{x} into \linkS4class{McmcFlatparList}.
#' @return Object of class \linkS4class{McmcParameters}
#' @examples
#' mcmc_parse_parnames(c("beta[1]", "beta[2]"))
#' mcmc_parse_parnames(c("beta.1", "beta.2"), mcmc_parparser_stan)
#' @export
mcmc_parse_parnames <- function(x, parser = mcmc_parparser_bugs) {
  flatpars <- parser(x)
  pararrays <- create_pararrays(flatpars)
  McmcParameters(flatpars = flatpars, pararrays = pararrays)
}

#' Check MCMC parameter names
#'
#' Check flat parameter names to see if they are consistent
#' with the parameter names generated by BUGS or Stan.
#'
#' @param x \code{character} vector of flat parameter names
#' @param style Eiter \code{"bugs"} or \code{"stan"}, to check
#' if the parameters are valid BUGS/JAGS or Stan names, respectively.
#' @return \code{logical} vector of same length as \code{x} with the validity of each
#' flat parameter name.
#' @rdname valid_mcmc_parnames
#' @export
#' @examples
#' valid_mcmc_parnames("beta[1]")
#' valid_mcmc_parnames("beta[1]", "stan")
#' valid_mcmc_parnames("beta.1", "stan")
valid_mcmc_parnames <- function(x, style="bugs") {
  if (style == "bugs") {
    as.logical(sapply(str_match_all(x, "^[A-Za-z.][A-Za-z.0-9]*(\\[\\d(,\\d)*\\])?$"), length))
  } else if (style == "stan") {
    as.logical(sapply(str_match_all(x, "^[A-Za-z][A-Za-z0-9_]*(\\.\\d)*$"), length))
  } else {
    stop("Option %s must be either %s or %s",
         sQuote("style"), dQuote("bugs"), dQuote("stan"))
  }
}
